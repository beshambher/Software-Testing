/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package st_lab;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Toolkit;
import java.awt.geom.AffineTransform;
import javax.swing.ImageIcon;
import javax.swing.JPanel;
import javax.swing.JScrollPane;

/**
 *
 * @author bishu
 */
public class CFG extends javax.swing.JFrame {

    /**
     * Creates new form test
     */
    public CFG(CFGPane CP) {
        initComponents(CP);
        CP.setPreferredSize(new Dimension(1000, CP.getMatrixSize() * 50));
        ImageIcon icon = new ImageIcon(System.getProperty("user.dir") + "\\src\\icons\\test_icon.gif");
        setIconImage(icon.getImage());
        Toolkit toolkit = getToolkit();
        Dimension size = toolkit.getScreenSize();
        setLocation(size.width / 2 - getWidth() / 2, size.height / 2 - getHeight() / 2);
        setTitle("CFG");
        this.setVisible(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents(CFGPane CPanel) {
        JScrollPane scroll = CPanel.scroll;

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(scroll, javax.swing.GroupLayout.DEFAULT_SIZE, 1006, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(scroll, javax.swing.GroupLayout.DEFAULT_SIZE, 700, Short.MAX_VALUE)
        );

        pack();
    }// </jeditor-fold>                        

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (Exception ex) {
            System.err.println(ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CFG(new CFGPane()).setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify                     
    // End of variables declaration                   
}

class CFGPane extends JPanel {

    JScrollPane scroll;
    private javax.swing.JButton zoomin = new javax.swing.JButton();
    private javax.swing.JButton zoomout = new javax.swing.JButton();
    private int zoom = 0;

    public class coor {

        int x, y, n, mx, my;

        public coor() {
            x = y = n = my = 0;
            mx = getWidth();
        }
    }

    public CFGPane() {
        setBackground(Color.white);
        setPreferredSize(new Dimension(1000, 2500));
        initComponents();
        scroll = new javax.swing.JScrollPane(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        zoomin = new javax.swing.JButton();
        zoomout = new javax.swing.JButton();

        zoomin.setText("+");
        zoomin.setToolTipText("Zoom in");
        zoomin.setSize(20, 10);
        zoomin.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                zoominMouseClicked(evt);
            }
        });

        zoomout.setText("-");
        zoomout.setToolTipText("Zoom out");
        zoomout.setSize(20, 10);
        zoomout.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                zoomoutMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(zoomin)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(zoomout))
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(zoomin)
                                .addComponent(zoomout))
                )
        );
    }// </editor-fold>                        

    private void zoomoutMouseClicked(java.awt.event.MouseEvent evt) {
        setPreferredSize(new Dimension(getWidth() - 100, getHeight() - 100));
        zoom = -100;
    }

    private void zoominMouseClicked(java.awt.event.MouseEvent evt) {
        setPreferredSize(new Dimension(getWidth() + 100, getHeight() + 100));
        zoom = 100;
    }

    private int m[][] = new int[100][100], n, i = 1, j, k;
    private coor c[];
    private String pr = "";

    public void setMatrix(int[][] M) {
        m = M;
    }

    public void setMatrixSize(int N) {
        n = N;
    }

    public int getMatrixSize() {
        return n;
    }

    public String inc() {
        String s = "";
        s += k;
        k++;
        return s;
    }

    public String inc2(int J) {
        String s = "";
        s += J;
        return s;
    }

    public void drawCircle(Graphics g, int x, int y, int r, String s) {
        if (s.length() == 1) {
            g.drawString(s, x - 3, y + 4);
        } else {
            g.drawString(s, x - 6, y + 4);
        }
        g.drawOval(x - r, y - r, r * 2, r * 2);
    }

    public void drawArrow(Graphics g1, int x, int y, int xx, int yy) {
        Graphics2D g = (Graphics2D) g1.create();
        double dx = xx - x, dy = yy - y;
        double a = Math.atan2(dy, dx);
        int len = (int) Math.sqrt(dx * dx + dy * dy);
        AffineTransform at = AffineTransform.getTranslateInstance(x, y);
        at.concatenate(AffineTransform.getRotateInstance(a));
        g.transform(at);
        g.drawLine(0, 0, len, 0);
        g.fillPolygon(new int[]{len, len - 4, len - 4, len},
                new int[]{0, -4, 4, 0}, 4);
    }

    @Override
    public void paintComponent(Graphics g) {
        setSize(new Dimension(getWidth() + zoom, getHeight() + zoom));
        validate();
        super.paintComponent(g);
        int x = getWidth() / 2;
        make(g);
    }

    public void func(Graphics g, int I, int J, int xst, int xend, int y) {
        try {
            int sm = 0, mid = (xend - xst) / 2;

            if (J == n - 1) {
                drawCircle(g, xst + mid, y, 13, inc2(J));
                drawCircle(g, xst + mid, y + 50, 13, inc2(n));
                drawArrow(g, xst + mid + 3, y + 13, xst + mid + 3, y + 47);
                return;
            }

            for (i = 0; i < n; i++) {
                sm += m[J][i];
            }
            //System.out.print("(i, j)= ("+I+", "+J+")  (xst, mid, xend, y)=("+xst+", "+mid+", "+xend+", "+y+") sm="+sm);
            if (sm == 0) {
                return;
            }
            //System.out.println(" circle "+J);

            drawCircle(g, xst + mid, y, 13, inc2(J));
            c[J].x = xst + mid;

            switch (sm) {
                case 1:
                    j = getIndex(J, 1);// System.out.println(" circle "+j);//": (x, y)=("+mid+", "+y+") (i, j)=("+I+", "+J+")");
                    // drawCircle(g, mid, y, 13, inc2(j));
                    if (j < J) { //System.out.println(J+" "+j);
                        drawArrow(g, c[J].x - 3, c[J].y - 13, c[j].x - 13, c[j].y + 5);
                    } else {
                        drawArrow(g, xst + mid + 3, y + 13, xst + mid + 3, y + 50 - 13);
                        func(g, J, j, xst, xend, y + 50);
                    }
                    break;
                case 2:
                    drawArrow(g, xst + mid + 3, y + 13, xst + (mid / 2) + 3, y + 50 - 13);
                    j = getIndex(J, 1);// System.out.println("Circle "+j);//+": (x, y)=("+mid+", "+y+") (i, j)=("+I+", "+J+")");
                    //drawCircle(g, mid, y, 13, inc2(j));
                    func(g, J, j, xst, xst + mid, y + 50);

                    drawArrow(g, xst + mid + 3, y + 13, xend - (mid / 2) + 3, y + 50 - 13);
                    j = getIndex(J, 2); //System.out.println("Circle "+j);//+": (x, y)=("+mid+", "+y+") (i, j)=("+I+", "+J+")");
                    //drawCircle(g, mid, y, 13, inc2(j));
                    func(g, J, j, xst + mid, xend, y + 50);
                    break;
            }
            if (sm > 2) {
                int xm = (xend - xst) / sm;
                for (int v = 1; v <= sm; v++) {
                    drawArrow(g, xst + mid + 3, y + 13, xst + (v - 1) * xm + (xm / 2) + 3, y + 50 - 13);
                    j = getIndex(J, v); //System.out.println("j="+j);
                    drawCircle(g, xst + (v - 1) * xm + (xm / 2) + 3, y + 50, 13, inc2(j));
                    drawArrow(g, xst + (v - 1) * xm + (xm / 2) + 3, y + 83, xst + mid + (v - 2), y + 140 - 13);
                }

                j = getIndex(j, 1);
                func(g, J, j, xst, xend, y + 140);
            }

            return;
        } catch (Exception e) {
            System.out.println("in func" + e);
        }
    }

    public int getIndex(int I, int s) {
        int sm = 0;
        for (int a = 0; a < n; a++) {
            sm += m[I][a];
            if (m[I][a] == 1 && sm == s) {
                return a;
            }
        }
        return 0;
    }

    public void make(Graphics g) {
        int i, j, x = getWidth() / 2, k;
        c = new coor[n];
        //f= new int[n];
        c[0] = new coor();
        c[0].x = x;
        c[0].y = 50;
        //f[0]=1;
        for (i = 1; i < n; i++) {
            c[i] = new coor();
            c[i].x = x;
            c[i].n = i;
        }

        func2(g, 0, 1, 0, getWidth(), 30);
        k = 0;
        for (i = 1; i < n; i++) {
            c[i].x = (c[i].mx + c[i].my) / 2;
            for (j = 1; j < n; j++) {
                if (i != j && c[i].x == c[j].x && c[i].y == c[j].y) {
                    c[j].x += 40;
                    c[j].y += 25;
                }
            }
            if ((k == (i - 1)) && (getOutDegree(i) == 1)) {
                k++;
            }
        }

        x = 50;
        for (i = 2; i < k; i++) {
            drawArrow(g, x + 13, 50, x + 37, 50);
            drawCircle(g, x, 50, 13, inc2(c[i - 1].n));
            x += 50;
        }

        drawCircle(g, x, 50, 13, inc2(c[k - 1].n));
        drawArrow(g, x, 63, c[k].x, c[k].y - 13 - ((k - 2) * 50 - 20));

        x = (k - 2) * 50 - 20; //System.out.println("y decrement: "+x+", k: "+k+", Yk-1: "+c[k].y+", Yk: "+c[k-1].y+", Yk-2: "+c[k-2].y);
        for (i = k; i < n; i++) {
            for (j = 1; j < n; j++) {
                if (m[i][j] == 1) {
                    if (i < j) {
                        drawArrow(g, c[i].x, c[i].y + 13 - x, c[j].x, c[j].y - 13 - x);
                    } else {
                        drawArrow(g, c[i].x, c[i].y - 13 - x, (j < k) ? (j * 50) : c[j].x, (j < k) ? 63 : (c[j].y + 13 - x));
                    }
                }
            }
            drawCircle(g, c[i].x, c[i].y - x, 13, inc2(c[i].n));
            //System.out.println(c[i].n+": "+c[i].x+", "+c[i].y);
        }
    }

    public void func2(Graphics g, int I, int J, int xst, int xend, int y) {
        try {
            //super.paintComponent(g);
            //int d: 0=mid, 1=right, 2=left.
            int sm = 0, mid = (xend - xst) / 2;

            if (J == n - 1) {
                if (c[J].mx > (xst + mid)) {
                    c[J].mx = xst + mid;
                }
                if (c[J].my < (xst + mid)) {
                    c[J].my = xst + mid;
                }
                if (c[J].y < y) {
                    c[J].y = y;
                }
                return;
            }

            for (i = 0; i < n; i++) {
                sm += m[J][i];
            }
            //System.out.print("(i, j)= ("+I+", "+J+")  (xst, mid, xend, y)=("+xst+", "+mid+", "+xend+", "+y+") sm="+sm);
            if (sm == 0) {
                return;
            }
            //System.out.println(" circle "+J);

            if (c[J].mx > (xst + mid)) {
                c[J].mx = xst + mid;
            }
            if (c[J].my < (xst + mid)) {
                c[J].my = xst + mid;
            }
            if (c[J].y < y) {
                c[J].y = y;
            }

            switch (sm) {
                case 1:
                    j = getIndex(J, 1);// System.out.println(" circle "+j);//": (x, y)=("+mid+", "+y+") (i, j)=("+I+", "+J+")");
                    // drawCircle(g, mid, y, 13, inc2(j));
                    if (j < J) { //System.out.println(J+" "+j);
                        //drawArrow(g, c[J].x - 3, c[J].y - 13, c[j].x - 13, c[j].y + 5);
                    } else {
                        //drawArrow(g, xst + mid + 3, y + 13, xst + mid + 3, y + 50 - 13);
                        func2(g, J, j, xst, xend, y + 50);
                    }
                    break;
                case 2:
                    //drawArrow(g, xst + mid + 3, y + 13, xst + (mid / 2) + 3, y + 50 - 13);
                    j = getIndex(J, 1);// System.out.println("Circle "+j);//+": (x, y)=("+mid+", "+y+") (i, j)=("+I+", "+J+")");
                    //drawCircle(g, mid, y, 13, inc2(j));
                    if (j > J) {
                        func2(g, J, j, xst, xst + mid, y + 50);
                    }
                    //drawArrow(g, xst + mid + 3, y + 13, xend - (mid / 2) + 3, y + 50 - 13);
                    j = getIndex(J, 2); //System.out.println("Circle "+j);//+": (x, y)=("+mid+", "+y+") (i, j)=("+I+", "+J+")");
                    //drawCircle(g, mid, y, 13, inc2(j));
                    if (j > J) {
                        func2(g, J, j, xst + mid, xend, y + 50);
                    }
                    break;
            }
            if (sm > 2) {
                int xm = (xend - xst) / sm;
                for (int v = 1; v <= sm; v++) {
                    //drawArrow(g, xst + mid + 3, y + 13, xst + (v - 1) * xm + (xm / 2) + 3, y + 50 - 13);
                    j = getIndex(J, v); //System.out.println("j="+j);
                    //drawCircle(g, xst + (v - 1) * xm + (xm / 2) + 3, y + 50, 13, inc2(j));

                    if (c[J].mx > (xst + (v - 1) * xm + (xm / 2) + 3)) {
                        c[J].mx = xst + (v - 1) * xm + (xm / 2) + 3;
                    }
                    if (c[J].my < (xst + (v - 1) * xm + (xm / 2) + 3)) {
                        c[J].my = xst + (v - 1) * xm + (xm / 2) + 3;
                    }
                    if (c[J].y < (y + 50)) {
                        c[J].y = y + 50;
                    }
                    if (j > J) {
                        func2(g, J, j, xst + (v - 1) * xm, xst + v * xm, y + 120);
                    }
                    //drawArrow(g, xst + (v - 1) * xm + (xm / 2) + 3, y + 83, xst + mid + (v - 2), y + 140 - 13);
                }
            }
        } catch (Exception e) {
            System.out.println("in func" + e);
        }
    }

    public int getOutDegree(int j) {
        int ii = 0;
        for (int ki = 0; ki < n; ki++) {
            ii += m[j][ki];
        }
        return ii;
    }
}
